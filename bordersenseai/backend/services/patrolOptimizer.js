// backend/services/patrolOptimizer.js
import PatrolRoute from '../models/PatrolRoute.js';
import Alert from '../models/Alert.js';
import AIModel from '../models/AIModel.js';

/**
 * AI-powered patrol route optimizer that generates optimal patrol routes
 * based on threat intelligence, historical data, and resource constraints.
 */

/**
 * Generate an optimized patrol route for a specific region
 * @param {string} regionId - ID of the region to generate route for
 * @param {Object} constraints - Optional constraints (time, resources, etc.)
 * @returns {Promise<Object>} - Optimized patrol route
 */
export const generateOptimizedRoute = async (regionId, constraints = {}) => {
  try {
    // 1. Get recent alerts in the region to identify high-risk areas
    const recentAlerts = await Alert.find({
      'location.region': regionId,
      timestamp: { $gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) } // Last 7 days
    }).sort({ timestamp: -1 }).lean();
    
    // 2. Get AI model predictions for the region
    const predictiveModel = await getRegionalPredictiveModel(regionId);
    
    // 3. Create a risk heatmap based on alert density, severity, and AI predictions
    const riskHeatmap = generateRiskHeatmap(recentAlerts, regionId, predictiveModel);
    
    // 4. Generate waypoints that prioritize high-risk areas
    const waypoints = generateWaypoints(riskHeatmap, constraints);
    
    // 5. Calculate optimization score based on coverage of high-risk areas
    const optimizationScore = calculateOptimizationScore(waypoints, riskHeatmap);
    
    // 6. Create and save the patrol route
    const route = new PatrolRoute({
      waypoints,
      optimizationScore,
      regionId,
      aiModelUsed: predictiveModel ? {
        modelId: predictiveModel._id,
        modelName: predictiveModel.name,
        modelVersion: `${predictiveModel.majorVersion}.${predictiveModel.minorVersion}.${predictiveModel.patchVersion}`,
        confidenceThreshold: predictiveModel.confidenceThreshold
      } : null
    });
    
    return await route.save();
  } catch (error) {
    console.error('Error generating optimized route:', error);
    throw error;
  }
};

/**
 * Get the appropriate predictive model for a region
 * @param {string} regionId - ID of the region
 * @returns {Promise<Object>} - AI model for prediction
 */
const getRegionalPredictiveModel = async (regionId) => {
  try {
    // Find an active predictive model for the region
    const model = await AIModel.findOne({
      type: 'predictive-patrolling',
      status: 'Active',
      deploymentRegions: regionId
    }).sort({ 'versionHistory.trainedAt': -1 }).exec();
    
    return model;
  } catch (error) {
    console.error('Error fetching predictive model:', error);
    return null;
  }
};

/**
 * Generate a risk heatmap based on alert data and AI model predictions
 * @param {Array} alerts - Recent alerts in the region
 * @param {string} regionId - ID of the region
 * @param {Object} predictiveModel - AI model for prediction (optional)
 * @returns {Object} - Risk heatmap
 */
const generateRiskHeatmap = (alerts, regionId, predictiveModel = null) => {
  // In a real implementation, this would use a more sophisticated algorithm
  // For now, we'll create a simple grid-based heatmap
  
  // Define region bounds (would come from a regions database in production)
  const regionBounds = getRegionBounds(regionId);
  
  // Create a grid of cells
  const gridSize = 10; // 10x10 grid
  const grid = Array(gridSize).fill().map(() => Array(gridSize).fill(0));
  
  // Populate grid with risk scores based on alerts
  alerts.forEach(alert => {
    // Get coordinates from the alert's location
    const coordinates = alert.location?.coordinates || alert.geo || { lat: 0, lon: 0 };
    const { lat, lon } = coordinates;
    
    // Convert geo coordinates to grid coordinates
    const x = Math.floor((lon - regionBounds.west) / (regionBounds.east - regionBounds.west) * gridSize);
    const y = Math.floor((lat - regionBounds.south) / (regionBounds.north - regionBounds.south) * gridSize);
    
    // Ensure coordinates are within grid bounds
    if (x >= 0 && x < gridSize && y >= 0 && y < gridSize) {
      // Add risk score based on alert severity
      const severityScore = getSeverityScore(alert.severity);
      
      // Apply model confidence as a multiplier if the alert was generated by an AI model
      let confidenceMultiplier = 1.0;
      if (alert.modelId && alert.confidence) {
        confidenceMultiplier = alert.confidence > 0.8 ? 1.2 : // High confidence increases risk
                              alert.confidence < 0.7 ? 0.8 : // Low confidence decreases risk
                              1.0; // Medium confidence unchanged
      }
      
      grid[y][x] += severityScore * confidenceMultiplier;
    }
  });
  
  // Apply AI model predictions if available
  if (predictiveModel) {
    applyPredictiveModelInsights(grid, regionBounds, gridSize, predictiveModel);
  }
  
  return {
    grid,
    regionBounds,
    gridSize
  };
};

/**
 * Apply predictive model insights to the risk heatmap
 * @param {Array} grid - Risk grid
 * @param {Object} regionBounds - Region boundaries
 * @param {number} gridSize - Size of the grid
 * @param {Object} model - AI model for prediction
 */
const applyPredictiveModelInsights = (grid, regionBounds, gridSize, model) => {
  // In a real implementation, this would call the AI model's prediction API
  // For now, we'll simulate predictions by adding risk to border areas
  
  // Simulate higher risk near borders (edges of the grid)
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      // Calculate distance from edge (0 = edge, 0.5 = center)
      const edgeDistanceX = Math.min(x, gridSize - 1 - x) / (gridSize / 2);
      const edgeDistanceY = Math.min(y, gridSize - 1 - y) / (gridSize / 2);
      const edgeDistance = Math.min(edgeDistanceX, edgeDistanceY);
      
      // Add more risk to cells closer to the edge
      const edgeRiskFactor = Math.max(0, 1 - edgeDistance) * 2;
      
      // Apply model confidence threshold as a quality factor
      const qualityFactor = model.confidenceThreshold || 0.7;
      
      // Add the predictive risk to the grid
      grid[y][x] += edgeRiskFactor * qualityFactor * 3; // Scale factor for prediction impact
    }
  }
  
  // In a real implementation, we would also consider:
  // - Seasonal patterns
  // - Time of day patterns
  // - Weather conditions
  // - Recent intelligence reports
};

/**
 * Generate waypoints based on risk heatmap and constraints
 * @param {Object} heatmap - Risk heatmap
 * @param {Object} constraints - Route constraints
 * @returns {Array} - Array of waypoints
 */
const generateWaypoints = (heatmap, constraints) => {
  const { grid, regionBounds, gridSize } = heatmap;
  const { maxWaypoints = 10, maxDistance = 50 } = constraints;
  
  // Find high-risk cells
  const riskCells = [];
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      if (grid[y][x] > 0) {
        riskCells.push({ x, y, risk: grid[y][x] });
      }
    }
  }
  
  // Sort cells by risk score (highest first)
  riskCells.sort((a, b) => b.risk - a.risk);
  
  // Select top N cells based on risk score
  const selectedCells = riskCells.slice(0, maxWaypoints);
  
  // Convert cells to geo coordinates
  const waypoints = selectedCells.map(cell => {
    const lon = regionBounds.west + (cell.x / gridSize) * (regionBounds.east - regionBounds.west);
    const lat = regionBounds.south + (cell.y / gridSize) * (regionBounds.north - regionBounds.south);
    
    // Calculate ETA based on distance and average patrol speed
    const now = Date.now();
    const etaOffset = calculateEtaOffset(cell, selectedCells[0], constraints);
    
    return {
      lat,
      lon,
      eta: new Date(now + etaOffset)
    };
  });
  
  return waypoints;
};

/**
 * Calculate optimization score for a set of waypoints
 * @param {Array} waypoints - Array of waypoints
 * @param {Object} heatmap - Risk heatmap
 * @returns {number} - Optimization score (0-1)
 */
const calculateOptimizationScore = (waypoints, heatmap) => {
  // In a real implementation, this would use a more sophisticated algorithm
  // that considers multiple factors like:
  // - Coverage of high-risk areas
  // - Patrol route efficiency (distance, time)
  // - Resource utilization
  // - Historical effectiveness of similar routes
  
  // Calculate coverage score - how well do waypoints cover high-risk areas?
  const coverageScore = calculateCoverageScore(waypoints, heatmap);
  
  // Calculate efficiency score - how efficient is the patrol route?
  const efficiencyScore = calculateEfficiencyScore(waypoints);
  
  // Combine scores with appropriate weights
  const weightedScore = (coverageScore * 0.7) + (efficiencyScore * 0.3);
  
  // Ensure score is between 0 and 1
  return Math.min(1, Math.max(0, weightedScore));
};

/**
 * Calculate how well waypoints cover high-risk areas
 * @param {Array} waypoints - Array of waypoints
 * @param {Object} heatmap - Risk heatmap
 * @returns {number} - Coverage score (0-1)
 */
const calculateCoverageScore = (waypoints, heatmap) => {
  // Simple implementation - ratio of waypoints to grid size
  const { gridSize } = heatmap;
  const totalCells = gridSize * gridSize;
  const coverageRatio = Math.min(1, waypoints.length / (totalCells * 0.2)); // Assume 20% coverage is optimal
  
  // Add randomness to simulate more complex calculations
  return 0.6 + (coverageRatio * 0.3) + (Math.random() * 0.1);
};

/**
 * Calculate efficiency of patrol route
 * @param {Array} waypoints - Array of waypoints
 * @returns {number} - Efficiency score (0-1)
 */
const calculateEfficiencyScore = (waypoints) => {
  // Simple implementation - based on number of waypoints (fewer is more efficient)
  const optimalWaypoints = 8; // Assume 8 waypoints is optimal
  const waypointRatio = Math.min(1, optimalWaypoints / Math.max(1, waypoints.length));
  
  // Add randomness to simulate more complex calculations
  return 0.5 + (waypointRatio * 0.4) + (Math.random() * 0.1);
};

/**
 * Get severity score based on alert severity
 * @param {string} severity - Alert severity (Low, Medium, High, Critical)
 * @returns {number} - Severity score
 */
const getSeverityScore = (severity) => {
  switch (severity) {
    case 'Critical': return 10;
    case 'High': return 5;
    case 'Medium': return 2;
    case 'Low': return 1;
    default: return 0;
  }
};

/**
 * Get region bounds based on region ID
 * @param {string} regionId - ID of the region
 * @returns {Object} - Region bounds (north, south, east, west)
 */
const getRegionBounds = (regionId) => {
  // In a real implementation, this would fetch region bounds from a database
  // For now, return dummy bounds based on region ID
  
  // Simulate different regions along the India-China border
  const regions = {
    'ladakh': { north: 35.0, south: 32.0, east: 80.0, west: 76.0 },
    'himachal': { north: 33.0, south: 30.0, east: 79.0, west: 75.0 },
    'uttarakhand': { north: 31.5, south: 28.5, east: 81.0, west: 77.0 },
    'sikkim': { north: 28.0, south: 27.0, east: 89.0, west: 87.5 },
    'arunachal': { north: 29.0, south: 26.5, east: 97.0, west: 91.5 }
  };
  
  return regions[regionId] || { north: 34.0, south: 32.0, east: 80.0, west: 76.0 };
};

/**
 * Calculate ETA offset for a waypoint
 * @param {Object} cell - Grid cell
 * @param {Object} startCell - Starting cell
 * @param {Object} constraints - Route constraints
 * @returns {number} - ETA offset in milliseconds
 */
const calculateEtaOffset = (cell, startCell, constraints) => {
  // Calculate distance between cells
  const distance = Math.sqrt(Math.pow(cell.x - startCell.x, 2) + Math.pow(cell.y - startCell.y, 2));
  
  // Assume average patrol speed of 5 km/h
  const averageSpeed = constraints.averageSpeed || 5; // km/h
  
  // Convert grid distance to km (approximate)
  const distanceKm = distance * 5; // Assuming each grid cell is roughly 5km
  
  // Calculate time in hours
  const timeHours = distanceKm / averageSpeed;
  
  // Convert to milliseconds
  return timeHours * 60 * 60 * 1000;
};